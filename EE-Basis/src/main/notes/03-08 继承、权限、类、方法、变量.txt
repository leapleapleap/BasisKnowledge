继承的概念:
    继承是面向对象三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，以及追加属性和方法

继承:
    继承的格式:extends
    继承后类的成员的访问特点:

    在子类方法中访问一个变量，采用的是就近原则。
    1. 子类局部范围找
    2. 子类成员范围找
    3. 父类成员范围找
    4. 如果都没有就报错(不考虑父亲的父亲…)

    方法的重写: Override

关键字：
    package:包就是文件夹，用来管理类文件的
    import:使用不同包下的类时，使用的时候要写类的全路径，写起来太麻烦了。
           为了简化带包的操作，Java就提供了导包的功能
    final：final 代表最终的意思，可以修饰成员方法、成员变量、类
    static：static 关键字是静态的意思，可以修饰【成员方法】、【成员变量】

001_继承
	为什么要使用继承？
		提高代码的复用

	继承的格式？
		public class 子类 extends 父类{
            //Xxx
		}
	子类能不能有自己特有的内容？

002_继承的好处和弊端
	继承提高代码的复用性指的是什么？
	继承提高代码的维护性指的是什么？
	继承有什么弊端？

	什么时候应该使用继承？

003_继承中变量的访问特点
	在子类的方法中使用一个变量，查找顺序是咋样的？
		就近原则

004_super
	super：
		它其实就是代表的一个父类的引用；

	如何指定获取本类的成员变量？
	    this.成员变量名
	如何指定获取父类的成员变量？
		super.成员变量名

005_继承中构造方法的访问特点
	子类构造方法的执行，父类构造方法为什么会执行？
	子类构造方法中，如何手动调用父类的构造方法？
		super(参数)

006_继承中成员方法的访问特点
	通过 子类对象.方法名() 调用方法，方法的查询流程？
	如何手动调用父类的成员方法？
		super.成员变量名();

007_super内存图

008_方法重写
	什么是方法重写？
		子类中出现了和父类一模一样声明的方法

	什么时候使用方法重写？
		当父类的方法不满足子类的需求时，需要重写

	@Override有什么作用？
        检测

009_方法重写注意事项
	父类中的私有方法，子类能不能重写？ 不能
	子类重写父类方法，子类方法声明的访问权限有什么要求？(了解)
        有更多的访问权限，有更少的异常抛出

010_Java中继承的注意事项
	一个类能不能同时 extends 多个类？
	java中支不支持多层继承？
        不能多继承但支持多层继承
        一个类可以实现多个接口，间接实现了多继承

011_老师和学生

012_猫和狗

013_package
	什么是包？
	包有什么作用？
	包的定义格式？
	package 包名;

014_import
	导包的格式？
		import 包名.类名；
	*********************
		import 包名.*
			把某个包下的所有类都导进来！！！

015_权限修饰符(理解)
	权限修饰符有哪些？
	权限修饰符权限从大到小依次为？

				同类中			同包中 			不同包子类		不包非子类
    public 		  Y			      Y			       Y				Y
    protected	  Y			      Y			       Y				N
    默认  		  Y			      Y			       N				N
    private		  Y			      N			       N				N


016_final
	被final修饰的成员方法有什么特点？-- 不能被重写
	被final修饰的成员变量有什么特点？-- 不能被修改
	被final修饰的类有什么特点？     -- 不能有子类

017_final修饰局部变量
	final修饰引用类型变量，不能变的是什么？
        引用变量所指向的地址

018_static
	static修饰的成员变量有什么特点？
		可以被该类的所有对象共享！！！！

	思考：
		static修饰的成员属于谁？
		**************************
			普通的成员变量/成员方法,属于对象
			static修饰的成员变量/成员方法,属于类

			1.类是先于对象存在
			2.静态的成员是先于非静态的成员存在

019_static访问特点
	非静态成员方法能不能访问静态内容？ 可以
	静态成员方法能不能访问非静态内容？ 不可以--->因为静态的成员先于非静态的成员存在