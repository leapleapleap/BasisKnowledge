今日内容：
	数据结构（为了让我们更好的理解集合）
	List集合（简单）
	Set集合(重点)
	Collections工具类

02_数据结构_栈
	栈结构的入口和出口？
	栈结构的数据存取特点？

03_数据结构_队列
	队列结构的出口和入口？
	队列结构的数据存取特点？

04_数据结构_数组
	数组的特点？
		查询快     有索引
		增删慢     长度固定，所以要增和删的时候必须创建新的数组

05_数据结构_链表
	链表的特点？
        查询慢     没有索引，每次查询都得从头部开始，直到查到为止
		增删快     每次增和删的动作不需要重新创建，而是在原有的基础上进行插入或者移除

06_数据结构_红黑树
	树形结构的出现是为了提高数据的查询效率

==================================================
栈
    先进后出
队列
    先进先出
数组
    查找快，增删慢
        长度固定，根据索引可以快速的访问某一个位置的元素
链表
    查找慢，增删快
二叉树

红黑树
==================================================
07_List集合_介绍&常用方法
	索引相关的几个方法？
        增     add(int index,E e)
		删     E remove(int index)   返回被删除的元素
		改     E set(int index,E e)  返回被替换的值
		查     get(int index)

08_ArrayList集合
	ArrayList的底层是用什么数据结构实现的？
		数组

	ArrayList的特点？
		查询快，增删慢，线程不安全(操作效率较高)

09_LinkedList集合
	LinkedList的底层用什么数据结构实现的？
		链表
	LinkedList的特点？
		查询慢，增删快，线程不安全(操作效率较高)
	添加相关方法？
	获取相关方法？
	删除相关方法？

10_Vector集合（了解）
	Vector的底层是用什么数据结构实现的？
		数组
	Vector的特点？
		查询快，增删慢，线程安全(操作效率较低)
---------------------------------------------------------
        使用hashSet集合是必须重写hashCode()方法和equals()方法
        在定义类时按需求重写toString()方法

11_HashSet集合介绍
	Set集合的特点：
		元素唯一
		元素的存和取无序

	HashSet的底层是什么数据结构实现的？
		哈希表

12_哈希值
	Object的hashCode方法，默认返回的是什么内容？
		代表的是一个对象的逻辑地址值

	重写hashCode方法之后，这个hash值是根据什么得来的？
		这个hash值是根据当前对象的内容计算出来的

		问：重写后的hashcode值，两个不同的对象，他们的hashcode值有没有可能一样？
			  有可能一样,如果两个对象的hashcode值一样了,这种情况叫做hash冲突!

	*********************
		二进制：
			0, 1
		八进制：
			0, 1, 2, 3, 4, 5, 6, 7
		十进制：
			0, 1, 2, 3, 4, 5, 6, 7, 8, 9
		十六进制：
			0, 1, 2, 3, 4, 5, 6, 7, 8, 9, a, b, c, d, e, f

13_HashSet集合存储数据的结构（哈希表）
	哈希表由哪些数据结构组成？
		jdk1.8前:
			数组+链表
		jdk1.8之后:
			数组+链表+红黑树

	哈希表存储数据的步骤？
		set.add(对象)
			1.调用对象.hashCode()得到该对象的hash值
			2.用hash值来确定对象在数组中的位置
			3.需要把对象挂到该数组位置处对应的链表上
				在挂之前，需要调用equals方法，判断链表上有没有相同内容的元素存在，如果没有，才能挂上

14_Set集合存储元素不重复的原理
	hashCode方法的作用？
	equals方法的作用？

15_HashSet存储自定义类型元素

16_LinkedHashSet集合
	底层：
		哈希表+链表(维护存和取的顺序)
	LinkedHashSet的特点？
		元素唯一,并且存取有序

17_可变参数
------------------------------------------------
    可变参数:是JDK1.5之后出现的新特性
    使用前提:
        当方法的参数列表数据类型已经确定,但是参数的个数不确定,就可以使用可变参数.(底层是一个数组)
    使用格式:(定义方法时使用)
        修饰符 返回值类型 方法名(数据类型...变量名){}
    可变参数的原理:
        可变参数底层就是一个数组,根据传递参数个数不同,会创建不同长度的数组,来存储这些参数
        传递的参数个数,可以是0个(不传递),1,2...多个

    可变参数的注意事项
        1.一个方法的参数列表,只能有一个可变参数
        2.如果方法的参数有多个,那么可变参数必须写在参数列表的末尾

    //可变参数的特殊(终极)写法
    public static void method(Object...obj){}
------------------------------------------------

18_Collections集合工具类的方法_addAll&shuffle

19_Collections集合工具类的方法_sort(List)
	sort方法默认排序规则？
		升序
	如果要对自定义类的对象进行排序,那么自定义类有什么要求？
		这个类必须实现Comparable接口,重写compareTo方法

	重写compareTo方法,怎么做是升序？怎么做是降序？
		this-参数：升序
		参数-this：降序

	**************
		Collections.sort()
			内部会遍历集合，然后调用
			if(list.get(i).compareTo(list.get(i+1))>0){
                swap...
			}

20_Collections集合工具类的方法_sort(List,Comparator)
	通过Comparator实现类对象提供比较规则的时候，如何升序？如何降序？
		升序：第一个参数-第二个参数；
		降序：第二个参数-第一个参数；
	思考：
		实现Comparable接口提供比较规则和通过Comparator实现类对象提供比较规则的使用场景？

		实现Comparable接口提供比较规则:       提供默认的比较规则
		通过Comparator实现类对象提供比较规则:  默认的比较规则不满足需求,或者是没有提供默认的比较规则再使用